for f in $(find . -name \*.h -or -name \*.cc); do cp $f $f.tmp; echo '#include "gc_pthread_redirects.h"' >$f; cat $f.tmp >>$f; rm $f.tmp; done
for f in $(find . -name \*.h -or -name \*.cc); do cp $f $f.tmp; echo '#include "gc.h"' >$f; cat $f.tmp >>$f; rm $f.tmp; done

export CPPFLAGS="-I/usr/local/mercury-11.07/lib/mercury/inc/"
export LDFLAGS="-L/usr/local/mercury-11.07/lib/mercury/lib/"

for f in $(find . -name \*.h -or -name \*.c); do cp $f $f.tmp; echo '#include "mygc.h"' >$f; cat $f.tmp >>$f; rm $f.tmp; done
for f in $(find . -name \*.hpp -or -name \*.cpp); do cp $f $f.tmp; echo '#include "mygc.h"' >$f; cat $f.tmp >>$f; rm $f.tmp; done
find . -name \*.h -or -name \*.c -or -name \*.hpp -or -name \*.cpp | xargs sed --in-place -e 's/\<malloc\>/GC_malloc/g'
find . -name \*.h -or -name \*.c -or -name \*.hpp -or -name \*.cpp | xargs sed --in-place -e 's/\<realloc\>/GC_realloc/g'
find . -name \*.h -or -name \*.c -or -name \*.hpp -or -name \*.cpp | xargs sed --in-place -e 's/\<free\>/GC_free/g'
export CPPFLAGS="-I$(pwd)/../gc-7.1/dist/include"
export LDFLAGS="-L$(pwd)/../gc-7.1/dist/lib"
export COIN_SKIP_PROJECTS="DyLP Vol"
./configure
find . -name Makefile | xargs sed --in-place -e 's/ADDLIBS =/ADDLIBS = -lgc/g'
make
make install
cp CoinUtils/src/mygc.h include/coin/





#define GC_DEBUG
#define GC_THREADS
#include <gc.h>

#ifdef __cplusplus
#ifndef MYGC
#define MYGC

inline void* operator new(std::size_t size) throw (std::bad_alloc)
{
  void* ptr = GC_malloc(size);
  if (!ptr) throw std::bad_alloc();
  return ptr;
}

inline void* operator new[](std::size_t size) throw (std::bad_alloc)
{
  void* ptr = GC_malloc(size);
  if (!ptr) throw std::bad_alloc();
  return ptr;
}

inline void operator delete(void* ptr) throw()
{
  if (ptr) GC_free(ptr);
}

inline void operator delete[](void* ptr) throw()
{
  if (ptr) GC_free(ptr);
}

inline void* operator new(std::size_t size, const std::nothrow_t&) throw()
{
  void* ptr = GC_malloc(size);
  return ptr;
}

inline void* operator new[](std::size_t size, const std::nothrow_t&) throw()
{
  void* ptr = GC_malloc(size);
  return ptr;
}

inline void operator delete(void* ptr, const std::nothrow_t&) throw()
{
  if (ptr) GC_free(ptr);
}

inline void operator delete[](void* ptr, const std::nothrow_t&) throw()
{
  if (ptr) GC_free(ptr);
}

#endif
#endif

