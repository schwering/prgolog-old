<!-- vim:syntax=off:textwidth=80:shiftwidth=2:softtabstop=2:expandtab
-->
<html>
  <head>
  </head>
  <body>
    <h1>Mercury Golog interpreter</h1>
    <p>Christoph Schwering (schwering@gmail.com)</p>

    <p>
    This is about a Golog interpreter written in Mercury.
    <a href="http://www.cs.toronto.edu/cogrobo/main/systems/">Golog</a> is a
    <a href="http://en.wikipedia.org/wiki/Situation_calculus">situation
      calculus</a>-based action language.
    <a href="http://www.mercury.csse.unimelb.edu.au/">Mercury</a> is a logic
    language similar to Prolog but with some ideas from Haskell.
    This brings a type system, determinism checks, and so on.
    If you prefer compile time errors over runtime errors and need to read
    your and other people's code, you might like Mercury.
    </p>

    <p>
    The interpreter is implemented in the file <a
      href="prgolog.m" style="font-weight: bold;">prgolog.m</a> and two helpers,
    <a href="prgolog.nice.m" style="font-weight: bold;">prgolog.nice.m</a> for a
    nicer syntax and
    <a href="prgolog.fluents.m" style="font-weight: bold;">prgolog.fluents.m</a>
    for some convenience functions for fluent formulas.
    <ul>
      <li> Nonderministic pick is NOT implemented. I'll probably go with the
      pick restricted to finite domains. </li>
      <li> Semantics from my diploma thesis:
      <ul>
        <li> Transition semantics using program decomposition.
        <li> Decision theory to resolve nondeterminism.
        <li> Stochastic actions.
        <li> Dropped support for continuous change and time.
      </ul>
      </li>
    </ul>
    As example, I implemented a maze in <a href="maze.m" style="font-weight:
      bold;">maze.m</a> consisting of four rooms, each of which as two doors.
    The agent wants to get from the top left to the bottom right.
    The agent's actions are deterministic (i.e., non-stochastic).
    </p>



    <h2>Benchmarks</h2>

    <p>
    I have tested Mercury for different room sizes.
    To compare it to ECLiPSe-CLP, I have re-implemented the same interpreter and
    maze in ECLiPSe-CLP.
    Mercury is compiled to binary code by default, but also supports Java as
    backend (and .NET, Erlang, and some more).<br />
    Hence, our test has already three dimensions: Mercury/binary vs Mercury/Java
    vs ECLiPSe-CLP.
    </p>

    <p>
    In the maze, there is a fluent called unvisited/2 which holds iff the given
    position has been visited in a previous situation.
    I have tested two alternative implementations of this fluent.
    The first <em>naively</em> uses the pos/1 fluent excessively and therefore
    induces a great number of regressions.
    The second does not rely on pos/1 and is therefore called
    <em>standalone</em>.
    Becaues it uses much less regression, the standalone variant is much faster.
    But we will see that if we <a
      href="http://en.wikipedia.org/wiki/Memoization">memoize</a> (aka tabling,
    that is, caching), pos/1, the naive unvisited/2 becomes incredibly
    fast.
    See <a href="#unvisited">below</a> for details on unvisited/2.<br />
    Now, our test has the following dimensions:
    <ul>
      <li> Mercury/binary with naive unvisited/2 with tabling </li>
      <li> Mercury/binary with naive unvisited/2 (without tabling) </li>
      <li> Mercury/binary with standalone unvisited/2 (without tabling, since
      this makes no sense here) </li>
      <li> Mercury/Java with naive unvisited/2 (without tabling, which is not
      supported in the Java backend) </li>
      <li> Mercury/Java with standalone unvisited/2 (without tabling) </li>
      <li> ECLiPSe-CLP with naive unvisited/2 (without tabling, which is not
      supported by ECLiPSe-CLP) </li>
      <li> ECLiPSe-CLP with standalone unvisited/2 (without tabling) </li>
    </ul>
    </p>

    <h3>Some Fancy Charts</h3>

    <p>
    The extensive table of runtimes is a bit confusing, so you might prefer the
    following charts.
    Hints for a quicker understanding:
    <ul>
      <li> Mercury/binary is blue, Mercury/Java in orange, ECLiPSe-CLP in
      green. </li>
      <li> Naive unvisited/2 has empty circles, standalone unvisited/2 has
      filled circles, naive unvisited/2 with tabling has squares. </li>
    </ul>
    </p>

    <p>
    Let's first have a look at how Mercury/binary, Mercury/Java, ECLiPSe-CLP
    performs under comparable conditions, that is, all using the <em>naive</em>
    unvisited/2 predicate:<br />
    <img src="plot_naive.svg" alt="plot of Mercury/binary, Mercury/Java, and
    ECLiPSe-CLP using naive unvisited/2" /><br />
    Surprisingly, the performance of Mercury/binary degrades after room size
    40.
    I don't know why this is.
    I also don't know why the <em>Java</em> version is faster than the
    <em>binary</em> Mercury version.
    Maybe both results are due to the virtual machines doing some
    optimizations?
    Note that the naive unvisited/2 leads to <em>many</em> regressions of
    pos/2 which might have to do with this.
    </p>

    <p>
    Again under comparable conditions, but now using the <em>standalone</em>
    unvisited/2 predicate, Mercury is faster than ECLiPSe-CLP, but the Java
    version is still a bit faster than the binary:<br />
    <img src="plot_stndaln.svg" alt="plot of Mercury/binary, Mercury/Java, and
    ECLiPSe-CLP using standalone unvisited/2" />
    </p>

    <p>
    But Mercury offers <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>
    aka tabling.
    This sounds very promising because we very often evaluate the same fluent
    in the same situation due to regression.
    When we enable tabling for the pos/1 fluent and use the <em>naive</em>
    unvisited/2, which makes heavy use of pos/1, we get the following
    results:<br />
    <img src="plot_binary.svg" alt="plot of Mercury/binary using tabled naive,
    naive, and standalone unvisited/2" /><br />
    The tabling has such a great effect that the <em>tabled naive</em>
    version even surpasses the <em>standalone</em> unvisited/2!
    </p>

    <p>
    And the race is not even close:
    <em>tabling</em> and <em>naive</em> unvisited/2 outscores all other
    variants, even the <em>standalone</em> versions:<br />
    <img src="plot_best.svg" alt="plot of Mercury/binary, Mercury/Java, and
    ECLiPSe-CLP using standalone unvisited/2" /><br />
    </p>

    <p>
    Let's finally throw everything together in one chart:<br />
    <img src="plot_all.svg" alt="plot of Mercury/binary, Mercury/Java, and
    ECLiPSe-CLP using naive tabled, naive, and standalone unvisited/2" /><br />
    </p>

    <h3>The Complete Table</h3>

    <p>The complete table of runtimes is a bit confusing:
    <pre>
       +------+---------------------------------------+---------------+
       |      |    M    e    r    c    u    r    y    | E C L i P S e |
       |      +-----------------------+---------------+---------------+
       | Room |   B  i  n  a  r  y    |    J a v a    | E C L i P S e |
       |      +-------+---------------+---------------+---------------+
       | Size |Tabling|  No  Tabling  |  No  Tabling  |  No  Tabling  |
       |      +-------+-------+-------+-------+-------+-------+-------+
       |      | naive | naive |stndaln| naive |stndaln| naive |stndaln|
       +------+-------+-------+-------+-------+-------+-------+-------+
       |   3  |  0.02 |  0.03 |  0.02 |  0.82 |  0.77 |  0.87 |  0.25 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  10  |  0.21 |  0.90 |  0.35 |  1.50 |  1.27 |  6.29 |  2.63 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  15  |  0.41 |  3.08 |  0.79 |  2.79 |  1.60 | 12.24 |  5.47 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  20  |  0.68 |  7.75 |  1.44 |  5.29 |  2.07 | 19.19 |  8.85 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  30  |  1.55 | 26.90 |  3.48 | 15.79 |  3.34 | 38.44 | 18.27 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  40  |  2.63 | 63.16 |  6.36 | 37.49 |  5.10 | 61.90 | 30.31 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  50  |  4.16 |125.02 |  9.85 | 73.89 |  7.51 | 90.33 | 45.22 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  60  |  6.05 |221.01 | 14.81 |122.98 | 10.78 |126.04 | 64.23 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  70  |  7.76 |358.04 | 20.17 |181.52 | 15.18 |160.88 | 81.30 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  80  | 10.50 |544.89 | 27.33 |258.81 | 19.04 |205.34 |104.59 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |Column|  (1)  |  (2)  |  (3)  |  (4)  |  (5)  |  (6)  |  (7)  | 
       +------+-------+-------+-------+-------+-------+-------+-------+
    </pre>

    <p>
    Durations are given in seconds on a Intel Core 2 Duo @ 2.26 GHz.
    </p>

    <h3>How are times measured?</h3>
    <p>
    The Mercury times are measured by GNU's time utility, i.e., they represent
    the process's runtime (this includes the JVM initilization in the Java
    case).
    ECLiPSe-CLP was measured using its profile/1 predicate.
    </p>

    <h3>Memoization / Tabling</h3>
    <p>
    As you can see, memoization aka tabling (caching of functions and
    predicates) of the pos/1 fluent speeds the things greatly, so that the
    naive unvisited/2 doesn't look so bad after all.
    But of course, memoization means memory consumption; I haven't found yet
    how to limit that.
    According to the Mercury mailing list, probabilistic tabling (only cache
    some percent) has been implemented by some people, but I haven't found it
    anywhere.
    </p>

    <a name="unvisited" />
    <h3>What is the naive / standalone unvisited/2?</h3>
    <p>
    The naive unvisited/2 naively uses pos/1 to check whether or not P
    has been visited yet:
    <pre>
     unvisited(P, S1) :-
         pos(S1) \= P,
         (   S1 = do(_, S), unvisited(P, S)
         ;   S1 = s0
         ).
    </pre>
    The standalone unvisited/2 avoids regressing pos/1 that often:
    <pre>
     unvisited(P, S) :- unvisited(P, _, S).
     unvisited(P1, P3, S1) :-
         (   S1 = s0, P3 = start
         ;   S1 = do(A, S), unvisited(P1, P2, S), P3 = new_pos(A, P2)
         ),
         P1 \= P3.
    </pre>
    That is, unvisited/3 imitates the pos/1 fluent function to avoid many
    needless regressions of pos/1. I call this the stand-alone implementation,
    because it does not use pos/1.
    </p>

    <p>
    Mercury also supports AND-parallelization. I've used it to parallelize the
    look-ahead, but it doesn't improve performance.
    </p>
  </body>
</html>

