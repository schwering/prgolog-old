<!-- vim:syntax=off:textwidth=80:shiftwidth=2:softtabstop=2:expandtab
-->
<html>
  <head>
  </head>
  <body>
    <h1>Mercury Golog interpreter</h1>
    <p>Christoph Schwering (schwering@gmail.com)</p>

    <p>
    This is about a Golog interpreter written in Mercury.
    <a href="http://www.cs.toronto.edu/cogrobo/main/systems/">Golog</a> is a
    <a href="http://en.wikipedia.org/wiki/Situation_calculus">situation
      calculus</a>-based action language.
    <a href="http://www.mercury.csse.unimelb.edu.au/">Mercury</a> is a logic
    language similar to Prolog but with some ideas from Haskell.
    This brings a type system, determinism checks, and so on.
    If you prefer compile time errors over runtime errors and need to read
    your and other people's code, you might like Mercury.
    </p>

    <p>
    The interpreter is implemented in the file <a
      href="prgolog.m">prgolog.m</a>.
    <ul>
      <li> Nonderministic pick is NOT implemented. </li>
      <li> Semantics from my diploma thesis:
      <ul>
        <li> Transition semantics using program decomposition.
        <li> Decision theory to resolve nondeterminism.
        <li> Stochastic actions.
        <li> Dropped support for continuous change and time.
      </ul>
      </li>
    </ul>
    As example, I implemented a maze in <a href="maze.m">maze.m</a> consisting
    of four rooms, each of which as two doors.
    The agent wants to get from the top left to the bottom right.
    The agent's actions are deterministic (i.e., non-stochastic).
    See maze.m for details.
    </p>



    <h2>Benchmarks</h2>

    <p>
    I have tested Mercury vs ECLiPSe-CLP for different room sizes (the size
    denotes the width and height).
    For the unvisited/2 fluent, which holds iff the given position has been
    visited in a previous situation, I have tested two different
    implementations, one being the naive implementation ("naive", uses pos/1)
    and the other one the standalone implementation ("stndaln", doesn't use
    pos/1 and thus avoids many regressions).
    See <a href="#unvisited">below</a> for details on unvisited/2 and a short
    interpretation of this table:
    </p>

    <h3>Some Fancy Charts</h3>

    <p>
    Let's first have a look at how Mercury/binary, Mercury/Java, ECLiPSe-CLP
    performs under comparable conditions, that is, all using the <em>naive</em>
    unvisited/2 predicate:<br />
    <img src="plot_naive.svg" alt="plot of Mercury/binary, Mercury/Java, and
    ECLiPSe-CLP using naive unvisited/2" /><br />
    Surprisingly, the performance of Mercury/binary degrades after room size
    40.
    I don't know why this is.
    I also don't know why the <em>Java</em> version is faster than the
    <em>binary</em> Mercury version.
    Maybe both results have to do with the virtual machines doing some
    optimizations?
    Note that the naive unvisited/2 leads to <em>many</em> regressions of
    pos/2 which might have to do with this.
    </p>

    <p>
    Again under comparable conditions, but now using the <em>standalone</em>
    unvisited/2 predicate, Mercury is faster than ECLiPSe-CLP, but the Java
    version is still a bit faster than the binary:<br />
    <img src="plot_stndaln.svg" alt="plot of Mercury/binary, Mercury/Java, and
    ECLiPSe-CLP using standalone unvisited/2" />
    </p>

    <p>
    But Mercury offers <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>
    aka tabling.
    This sounds very reasonable because we very often evaluate the same fluent
    in the same situation due to regression.
    When we enable tabling for the pos/1 fluent and use the <em>naive</em>
    unvisited/2, which makes heavy use of pos/1, we get the following
    results:<br />
    <img src="plot_binary.svg" alt="plot of Mercury/binary using tabled naive,
    naive, and standalone unvisited/2" /><br />
    The tabling has such a great effect that it the <em>tabled naive</em>
    version even surpasses the <em>standalone</em> unvisited/2!
    </p>

    <p>
    And the race is not even close!
    Using <em>tabling</em> and <em>naive</em> outscores all other
    variants, even the <em>standalone</em> versions:<br />
    <img src="plot_best.svg" alt="plot of Mercury/binary, Mercury/Java, and
    ECLiPSe-CLP using standalone unvisited/2" /><br />
    </p>

    <h3>The Complete Table</h3>

    <p>The complete table of runtimes is a bit confusing:
    <pre>
       +------+---------------------------------------+---------------+
       |      |    M    e    r    c    u    r    y    | E C L i P S e |
       |      +-----------------------+---------------+---------------+
       | Room |   B  i  n  a  r  y    |    J a v a    | E C L i P S e |
       |      +-------+---------------+---------------+---------------+
       | Size |Tabling|  No  Tabling  |  No  Tabling  |  No  Tabling  |
       |      +-------+-------+-------+-------+-------+-------+-------+
       |      | naive | naive |stndaln| naive |stndaln| naive |stndaln|
       +------+-------+-------+-------+-------+-------+-------+-------+
       |   3  |  0.02 |  0.03 |  0.02 |  0.82 |  0.77 |  0.87 |  0.25 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  10  |  0.21 |  0.90 |  0.35 |  1.50 |  1.27 |  6.29 |  2.63 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  15  |  0.41 |  3.08 |  0.79 |  2.79 |  1.60 | 12.24 |  5.47 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  20  |  0.68 |  7.75 |  1.44 |  5.29 |  2.07 | 19.19 |  8.85 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  30  |  1.55 | 26.90 |  3.48 | 15.79 |  3.34 | 38.44 | 18.27 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  40  |  2.63 | 63.16 |  6.36 | 37.49 |  5.10 | 61.90 | 30.31 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  50  |  4.16 |125.02 |  9.85 | 73.89 |  7.51 | 90.33 | 45.22 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  60  |  6.05 |221.01 | 14.81 |122.98 | 10.78 |126.04 | 64.23 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  70  |  7.76 |358.04 | 20.17 |181.52 | 15.18 |160.88 | 81.30 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |  80  | 10.50 |544.89 | 27.33 |258.81 | 19.04 |205.34 |104.59 |
       +------+-------+-------+-------+-------+-------+-------+-------+
       |Column|  (1)  |  (2)  |  (3)  |  (4)  |  (5)  |  (6)  |  (7)  | 
       +------+-------+-------+-------+-------+-------+-------+-------+
    </pre>

    <p>
    Durations are given in seconds on a Intel Core 2 Duo @ 2.26 GHz.
    </p>

    <h3>How are times measured?</h3>
    <p>
    The Mercury times are measured by GNU's time utility, i.e., they represent
    the process's runtime (this includes the JVM initilization in the Java
    case).
    ECLiPSe-CLP was measured using its profile/1 predicate.
    </p>

    <h3>Memoization / Tabling</h3>
    <p>
    As you can see, memoization aka tabling (caching of functions and
    predicates) of the pos/1 fluent speeds the things greatly, so that the
    naive unvisited/2 doesn't look so bad after all.
    But of course, memoization means memory consumption; I haven't found yet
    how to limit that.
    According to the Mercury mailing list, probabilistic tabling (only cache
    some percent) has been implemented by some people, but I haven't found it
    anywhere.
    </p>

    <a name="unvisited" />
    <h3>What is the naive / standalone unvisited/2?</h3>
    <p>
    The naive unvisited/2 naively uses pos/1 to check whether or not P
    has been visited yet:
    <pre>
     unvisited(P, S1) :-
         pos(S1) \= P,
         (   S1 = do(_, S), unvisited(P, S)
         ;   S1 = s0
         ).
    </pre>
    The standalone unvisited/2 avoids regressing pos/1 that often:
    <pre>
     unvisited(P, S) :- unvisited(P, _, S).
     unvisited(P1, P3, S1) :-
         (   S1 = s0, P3 = start
         ;   S1 = do(A, S), unvisited(P1, P2, S), P3 = new_pos(A, P2)
         ),
         P1 \= P3.
    </pre>
    That is, unvisited/3 imitates the pos/1 fluent function to avoid many
    needless regressions of pos/1. I call this the stand-alone implementation,
    because it does not use pos/1.
    </p>

    <p>
    Mercury also supports AND-parallelization. I've used it to parallelize the
    look-ahead, but it doesn't improve performance.
    </p>
  </body>
</html>

